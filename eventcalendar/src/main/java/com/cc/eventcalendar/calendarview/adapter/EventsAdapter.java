package com.cc.eventcalendar.calendarview.adapter;

import android.util.SparseArray;

import com.cc.eventcalendar.calendarview.ICalendarEvent;
import com.cc.eventcalendar.calendarview.util.OSTimeUtil;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.List;

/**
 * Created by ChengCn on 12/30/2015.
 */
public class EventsAdapter extends AbsOSEventAdapter {
    private Calendar mTempDate;
    private SparseArray<Collection<? extends BaseEvent>> mEvents;
    private EventFilter mFilter;

    public EventsAdapter() {
        mEvents = new SparseArray<>();
        mTempDate = Calendar.getInstance();
    }

    @Override
    public int getEventsCount() {
        return 0;
    }

    /**
     * Get the event of the specified key
     *
     * @param key the key that generated by the date.
     * @return a list of the event that happened on the date.
     * @see {@link #getKey(long)}
     */
    @Override
    public List<? extends ICalendarEvent> getEvent(int key) {
        List<? extends ICalendarEvent> events = (List<? extends ICalendarEvent>) mEvents.get(key);
        if (mFilter == null || events == null || events.isEmpty()) {
            return events;
        }

        List<ICalendarEvent> ret = new ArrayList<>();
        for (int i = events.size() - 1; i >= 0; i--) {
            if (mFilter.onFilterEvent(events.get(i))) {
                ret.add(events.get(i));
            }
        }

        return ret;
    }

    public SparseArray<Collection<? extends BaseEvent>> getEvents() {
        return mEvents;
    }

    /**
     * update one day of events
     *
     * @param events   the events of the day
     * @param dateTime the time in millisecond of the day.
     */
    public void updateOneDayEvents(List<? extends BaseEvent> events, long dateTime) {
        List<? extends BaseEvent> updated = null;
        if (events != null) {
            updated = new ArrayList<>(events);
        }
        mEvents.put(getKey(dateTime), updated);
        notifyDataSetChanged();
    }

    public synchronized void updateEvent(ICalendarEvent event) {
        for (int i = 0; i < mEvents.size(); i++) {
            List<BaseEvent> events = (List<BaseEvent>) mEvents.get(mEvents.keyAt(i));
            if (events == null || events.isEmpty()) {
                continue;
            }

            for (int j = 0;j < events.size(); j++) {
                if (events.get(j).getID().equalsIgnoreCase(event.getID())) {
                    BaseEvent tmp =  events.remove(j);
                    Calendar c= Calendar.getInstance();
                    c.setTimeInMillis(tmp.getStartTime());
                    mTempDate.setTimeInMillis(event.getStartTime());
                    if (OSTimeUtil.isSameDay(c, mTempDate)) {
                        events.add(j, (BaseEvent) event);
                    } else {
                        List<BaseEvent> oneDayEvents = getEventsOfEventDay(event);
                        if (oneDayEvents == null) {
                            oneDayEvents = new ArrayList<>();
                        }

                        oneDayEvents.add((BaseEvent) event);
                        mEvents.put(getKey(event.getStartTime()), oneDayEvents);
                    }
                    notifyDataSetChanged();
                    return;
                }
            }
        }
    }

    public void deleteEvent(ICalendarEvent event) {
        List<BaseEvent> events = getEventsOfEventDay(event);
        if (events == null || events.isEmpty()) {
            return;
        }

        for (int i = 0; i < events.size(); i++) {
            if (events.get(i).getID().equalsIgnoreCase(event.getID())) {
                events.remove(i);
                notifyDataSetChanged();
                return;
            }
        }
    }

    private List<BaseEvent> getEventsOfEventDay(ICalendarEvent event) {
        if (event == null || mEvents.size() <= 0) {
            return null;
        }

        mTempDate.setTimeInMillis(event.getStartTime());
        OSTimeUtil.changeToStartOfDay(mTempDate);
        long startTime = mTempDate.getTimeInMillis();
        return (List<BaseEvent>) mEvents.get(getKey(startTime));
    }

    /**
     * Check whether has event on the specified time.
     *
     * @param time the time in millisecond that to be checked
     * @return true if has event on the specified time, otherwise false.
     */
    public boolean hasEvent(long time) {
        List<? extends ICalendarEvent> events = (List<? extends ICalendarEvent>) mEvents.get(getKey(time));

        if (events == null) {
            return false;
        }

        if (mFilter == null) {
            return !events.isEmpty();
        }

        for (ICalendarEvent event : events) {
            if (mFilter.onFilterEvent(event)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Set the event of the adapter.
     *
     * @param events the list of the events.
     */
    public void setEvents(SparseArray<Collection<? extends BaseEvent>> events) {
        clearEvent();

        if (events == null || events.size() == 0) {
            notifyDataSetChanged();
            return;
        }

        mEvents = events;
        notifyDataSetChanged();
    }

    /**
     * Set the event of the adapter.
     *
     * @param events the list of the events.
     */
    public void setEvents(List<? extends ICalendarEvent> events) {
        clearEvent();
        if (events == null || events.isEmpty()) {
            notifyDataSetChanged();
            return;
        }

        addEvent(events);
    }

    /**
     * add a list of events to the adapter.
     *
     * @param events the added events list.
     */
    public void addEvent(List<? extends ICalendarEvent> events) {
        if (events == null || events.isEmpty()) {
            return;
        }

        for (ICalendarEvent event : events) {
            addEventToList(event);
        }

        notifyDataSetChanged();
    }

    /**
     * Add one event to the adapter.
     *
     * @param event the event that will be added.
     */
    public void addEvent(ICalendarEvent event) {
        addEventToList(event);

        notifyDataSetChanged();
    }

    private void addEventToList(ICalendarEvent event) {
        if (event == null) {
            return;
        }

        List<BaseEvent> tmp;
        mTempDate.setTimeInMillis(event.getStartTime());
        while (mTempDate.getTimeInMillis() < event.getEndTime()) {
            OSTimeUtil.changeToStartOfDay(mTempDate);
            tmp = (List<BaseEvent>) mEvents.get(getKey(mTempDate.getTimeInMillis()));
            if (tmp == null) {
                tmp = new ArrayList<>();
            }
            tmp.add((BaseEvent) event);
            mEvents.put(getKey(mTempDate.getTimeInMillis()), tmp);
            mTempDate.add(Calendar.DAY_OF_MONTH, 1);
        }
    }

    /**
     * Clear all of the event.
     */
    private void clearEvent() {
        mEvents.clear();
    }

    public void setEventFilter(EventFilter filter) {
        mFilter = filter;
        notifyDataSetChanged();
    }

    /**
     * The utility method that convert a date time in millisecond to a integer key.
     *
     * @param timeInMillis the date time in millisecond.
     * @return return a date time key.
     */
    public static int getKey(long timeInMillis) {
        return (int) (timeInMillis >>> 10);
    }

    /**
     * Event filter
     */
    public interface EventFilter {
        /**
         * Filter event.
         *
         * @param event the event that will be filter.
         * @return true if the event is expected. otherwise false.
         */
        boolean onFilterEvent(ICalendarEvent event);
    }
}
