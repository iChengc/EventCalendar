package com.cc.eventcalendar.calendarview.adapter;

import android.util.SparseArray;

import com.cc.eventcalendar.calendarview.ICalendarEvent;
import com.cc.eventcalendar.calendarview.util.OSTimeUtil;
import com.cc.eventcalendar.calendarview.util.StrUtil;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.List;

/**
 * Created by ChengCn on 12/30/2015.
 */
public class EventsAdapter extends AbsOSEventAdapter {
    private Calendar mTempDate;
    private SparseArray<Collection<? extends BaseEvent>> mEvents;
    private EventFilter mFilter;

    public EventsAdapter() {
        mEvents = new SparseArray<>();
        mTempDate = Calendar.getInstance();
    }

    @Override
    public int getEventsCount() {
        return 0;
    }

    /**
     * Get the event of the specified key
     *
     * @param key the key that generated by the date.
     * @return a list of the event that happened on the date.
     * @see {@link #getKey(long)}
     */
    @Override
    public List<? extends ICalendarEvent> getEvent(int key) {
        List<? extends ICalendarEvent> events = (List<? extends ICalendarEvent>) mEvents.get(key);
        if (mFilter == null || events == null || events.isEmpty()) {
            return events;
        }

        List<ICalendarEvent> ret = new ArrayList<>();
        for (int i = events.size() - 1; i >= 0; i--) {
            if (mFilter.onFilterEvent(events.get(i))) {
                ret.add(events.get(i));
            }
        }

        return ret;
    }

    public SparseArray<Collection<? extends BaseEvent>> getEvents() {
        return mEvents;
    }

    /**
     * update one day of events
     *
     * @param events   the events of the day
     * @param dateTime the time in millisecond of the day.
     */
    public void updateOneDayEvents(List<? extends BaseEvent> events, long dateTime) {
        List<BaseEvent> updated = new ArrayList<>();
        if (events != null) {
            updated.addAll(events);
        }

        updateCrossDayEvent(updated);
        List<BaseEvent> oneDayOldReservations = (List<BaseEvent>) mEvents.get(getKey(dateTime));
        mEvents.put(getKey(dateTime), updated);
        if (oneDayOldReservations == null || oneDayOldReservations.isEmpty()) {
            notifyDataSetChanged();
            return;
        }
        for (int i = oneDayOldReservations.size() - 1; i >= 0; i--) {
            for (int j = 0; j < updated.size(); j++) {
                if (oneDayOldReservations.get(i).getID().equals(updated.get(j).getID())) {
                    oneDayOldReservations.remove(i);
                    break;
                }
            }
        }

        if (!oneDayOldReservations.isEmpty()) {
            deleteCrossDayEvent(oneDayOldReservations);
        }
        notifyDataSetChanged();
    }


    private void updateCrossDayEvent(List<? extends BaseEvent> events) {
        if (events == null || events.isEmpty()) {
            return;
        }

        ICalendarEvent old;
        for (ICalendarEvent ev : events) {
            if (ev.getDuration() >= OSTimeUtil.MILLIS_IN_DAY) {
                old = getEventById(ev.getID());
                if (old != null) {
                    deleteEventInternal(old);
                }
                addEventToList(ev);
            }
        }
    }

    private void deleteCrossDayEvent(List<? extends BaseEvent> events) {
        if (events == null) {
            return;
        }

        ICalendarEvent tmp;
        for (ICalendarEvent ev : events) {
            if (ev.getDuration() >= OSTimeUtil.MILLIS_IN_DAY) {
                tmp = getEventById(ev.getID());
                if (tmp != null) {
                    deleteEventInternal(tmp);
                }
            }
        }
    }

    /**
     * update one calendar event.
     *
     * @param event the event that will be updated.
     */
    public synchronized void updateEvent(ICalendarEvent event) {
        if (event == null) {
            return;
        }

        for (int i = 0; i < mEvents.size(); i++) {
            List<BaseEvent> events = (List<BaseEvent>) mEvents.get(mEvents.keyAt(i));
            ICalendarEvent ev = getEventFromListById(events, event.getID());
            if (ev != null) {
                deleteEventInternal(ev);
                addEventToList(event);
                notifyDataSetChanged();
                return;
            }
        }
    }

    /**
     * Delete one event.
     *
     * @param event the event that will be deleted.
     * @return true if the event is deleted, otherwise false.
     */
    public boolean deleteEvent(ICalendarEvent event) {
        if (event == null) {
            return false;
        }

        ICalendarEvent ev = getEventById(event.getID());
        boolean isDeleted = deleteEventInternal(ev);
        if (isDeleted) {
            notifyDataSetChanged();
        }

        return isDeleted;
    }

    private boolean deleteEventInternal(ICalendarEvent event) {
        if (event == null) {
            return false;
        }

        boolean isDeleted = false;
        long eventTime = event.getStartTime();
        mTempDate.setTimeInMillis(eventTime);
        OSTimeUtil.changeToStartOfDay(mTempDate);
        eventTime = mTempDate.getTimeInMillis();
        while (event.getEndTime() > eventTime) {
            List<BaseEvent> events = (List<BaseEvent>) mEvents.get(getKey(eventTime));
            if (events == null || events.isEmpty()) {
                eventTime += OSTimeUtil.MILLIS_IN_DAY;
                continue;
            }

            for (int i = 0; i < events.size(); i++) {
                if (events.get(i).getID().equalsIgnoreCase(event.getID())) {
                    events.remove(i);
                    isDeleted = true;
                    break;
                }
            }

            eventTime += OSTimeUtil.MILLIS_IN_DAY;
        }
        return isDeleted;
    }

    private ICalendarEvent getEventFromListById(List<BaseEvent> reservations, String id) {
        if (reservations == null || StrUtil.isEmpty(id)) {
            return null;
        }

        for (ICalendarEvent reservation : reservations) {
            if (reservation.getID().equals(id)) {
                return reservation;
            }
        }
        return null;
    }

    /**
     * Get a calendar event by id.
     *
     * @param id the id of the calendar event.
     * @return the corresponding calendar event.
     */
    public ICalendarEvent getEventById(String id) {
        if (StrUtil.isEmpty(id)) {
            return null;
        }

        for (int i = 0; i < mEvents.size(); i++) {
            ICalendarEvent event = getEventFromListById((List<BaseEvent>) mEvents.get(mEvents.keyAt(i)), id);
            if (event != null) {
                return event;
            }
        }

        return null;
    }

    /**
     * Check whether has event on the specified time.
     *
     * @param time the time in millisecond that to be checked
     * @return true if has event on the specified time, otherwise false.
     */
    public boolean hasEvent(long time) {
        List<? extends ICalendarEvent> events = (List<? extends ICalendarEvent>) mEvents.get(getKey(time));

        if (events == null) {
            return false;
        }

        if (mFilter == null) {
            return !events.isEmpty();
        }

        for (ICalendarEvent event : events) {
            if (mFilter.onFilterEvent(event)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Set the event of the adapter.
     *
     * @param events the list of the events.
     */
    public void setEvents(SparseArray<Collection<? extends BaseEvent>> events) {
        clearEvent();

        if (events == null || events.size() == 0) {
            notifyDataSetChanged();
            return;
        }

        createEventsData(events);
        notifyDataSetChanged();
    }

    private void createEventsData(SparseArray<Collection<? extends BaseEvent>> events) {
        for (int i = 0; i < events.size(); i++) {
            final int key = events.keyAt(i);
            List<? extends BaseEvent> eventsOfDay = new ArrayList<>(events.get(key));
            mEvents.put(key, eventsOfDay);
        }
    }

    /**
     * Set the event of the adapter.
     *
     * @param events the list of the events.
     */
    public void setEvents(List<? extends ICalendarEvent> events) {
        clearEvent();
        if (events == null || events.isEmpty()) {
            notifyDataSetChanged();
            return;
        }

        addEvent(events);
    }

    /**
     * add a list of events to the adapter.
     *
     * @param events the added events list.
     */
    public void addEvent(List<? extends ICalendarEvent> events) {
        if (events == null || events.isEmpty()) {
            return;
        }

        for (ICalendarEvent event : events) {
            addEventToList(event);
        }

        notifyDataSetChanged();
    }

    /**
     * Add one event to the adapter.
     *
     * @param event the event that will be added.
     */
    public void addEvent(ICalendarEvent event) {
        addEventToList(event);

        notifyDataSetChanged();
    }

    private void addEventToList(ICalendarEvent event) {
        if (event == null) {
            return;
        }

        List<BaseEvent> tmp;
        mTempDate.setTimeInMillis(event.getStartTime());
        OSTimeUtil.changeToStartOfDay(mTempDate);
        while (mTempDate.getTimeInMillis() < event.getEndTime()) {
            tmp = (List<BaseEvent>) mEvents.get(getKey(mTempDate.getTimeInMillis()));
            if (tmp == null) {
                tmp = new ArrayList<>();
            }
            tmp.add((BaseEvent) event);
            mEvents.put(getKey(mTempDate.getTimeInMillis()), tmp);
            mTempDate.add(Calendar.DAY_OF_MONTH, 1);
        }
    }

    /**
     * Clear all of the event.
     */
    private void clearEvent() {
        mEvents.clear();
    }

    public void setEventFilter(EventFilter filter) {
        mFilter = filter;
        notifyDataSetChanged();
    }

    /**
     * The utility method that convert a date time in millisecond to a integer key.
     *
     * @param timeInMillis the date time in millisecond.
     * @return return a date time key.
     */
    public static int getKey(long timeInMillis) {
        return (int) (timeInMillis >>> 10);
    }

    /**
     * Event filter
     */
    public interface EventFilter {
        /**
         * Filter event.
         *
         * @param event the event that will be filter.
         * @return true if the event is expected. otherwise false.
         */
        boolean onFilterEvent(ICalendarEvent event);
    }
}
